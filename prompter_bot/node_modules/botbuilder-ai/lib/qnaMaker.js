"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botbuilder_core_1 = require("botbuilder-core");
const entities = require("html-entities");
const os = require("os");
const pjson = require('../package.json');
const request = require("request-promise-native");
const qnaTelemetryConstants_1 = require("./qnaTelemetryConstants");
const QNAMAKER_TRACE_TYPE = 'https://www.qnamaker.ai/schemas/trace';
const QNAMAKER_TRACE_NAME = 'QnAMaker';
const QNAMAKER_TRACE_LABEL = 'QnAMaker Trace';
/**
 * @private
 */
const htmlentities = new entities.AllHtmlEntities();
/**
 * Query a QnA Maker knowledge base for answers.
 *
 * @remarks
 * This class is used to make queries to a single QnA Maker knowledge base and return the result.
 *
 * Use this to process incoming messages with the [getAnswers()](#getAnswers) method.
 */
class QnAMaker {
    /**
     * Creates a new QnAMaker instance.
     * @param endpoint The endpoint of the knowledge base to query.
     * @param options (Optional) additional settings used to configure the instance.
     * @param telemetryClient The BotTelemetryClient used for logging telemetry events.
     * @param logPersonalInformation Set to true to include personally indentifiable information in telemetry events.
     */
    constructor(endpoint, options = {}, telemetryClient, logPersonalInformation) {
        this.endpoint = endpoint;
        if (!endpoint) {
            throw new TypeError('QnAMaker requires valid QnAMakerEndpoint.');
        }
        const { scoreThreshold = 0.3, top = 1, strictFilters = [], metadataBoost = [], timeout = 100000 } = options;
        this._options = {
            scoreThreshold,
            top,
            strictFilters,
            metadataBoost,
            timeout
        };
        this.validateOptions(this._options);
        this._telemetryClient = telemetryClient || new botbuilder_core_1.NullTelemetryClient();
        this._logPersonalInformation = logPersonalInformation || false;
    }
    /**
     * Gets a value indicating whether determines whether to log personal information that came from the user.
     */
    get logPersonalInformation() { return this._logPersonalInformation; }
    /**
      * Gets the currently configured botTelemetryClient that logs the events.
      */
    get telemetryClient() { return this._telemetryClient; }
    /**
     * Calls the QnA Maker service to generate answer(s) for a question.
     *
     * @remarks
     * Returns an array of answers sorted by score with the top scoring answer returned first.
     *
     * In addition to returning the results from QnA Maker, [getAnswers()](#getAnswers) will also
     * emit a trace activity that contains the QnA Maker results.
     *
     * @param context The Turn Context that contains the user question to be queried against your knowledge base.
     * @param options (Optional) The options for the QnA Maker knowledge base. If null, constructor option is used for this instance.
     * @param telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @param telemetryMetrics Additional metrics to be logged to telemetry with the QnaMessage event.
     */
    async getAnswers(context, options, telemetryProperties, telemetryMetrics) {
        if (!context) {
            throw new TypeError('QnAMaker.getAnswers() requires a TurnContext.');
        }
        const queryResult = [];
        const question = this.getTrimmedMessageText(context);
        const queryOptions = { ...this._options, ...options };
        this.validateOptions(queryOptions);
        if (question.length > 0) {
            const answers = await this.queryQnaService(this.endpoint, question, queryOptions);
            const sortedQnaAnswers = this.sortAnswersWithinThreshold(answers, queryOptions);
            queryResult.push(...sortedQnaAnswers);
        }
        // Log telemetry
        this.onQnaResults(queryResult, context, telemetryProperties, telemetryMetrics);
        await this.emitTraceInfo(context, queryResult, queryOptions);
        return queryResult;
    }
    /**
     * Calls [generateAnswer()](#generateanswer) and sends the resulting answer as a reply to the user.
     * @deprecated Instead, favor using [QnAMaker.getAnswers()](#getAnswers) to generate answers for a question.
     *
     * @remarks
     * Returns a value of `true` if an answer was found and sent. If multiple answers are
     * returned the first one will be delivered.
     * @param context Context for the current turn of conversation with the user.
     */
    async answer(context) {
        if (!context) {
            throw new TypeError('QnAMaker.answer() requires a TurnContext.');
        }
        const { top, scoreThreshold } = this._options;
        const question = this.getTrimmedMessageText(context);
        const answers = await this.generateAnswer(question, top, scoreThreshold);
        await this.emitTraceInfo(context, answers, this._options);
        if (answers.length > 0) {
            await context.sendActivity({ text: answers[0].answer, type: 'message' });
            return true;
        }
        return false;
    }
    /**
     * Calls the QnA Maker service to generate answer(s) for a question.
     *
     * @deprecated Instead, favor using [QnAMaker.getAnswers()](#getAnswers) to generate answers for a question.
     *
     * @remarks
     * Returns an array of answers sorted by score with the top scoring answer returned first.
     *
     * @param question The question to answer.
     * @param top (Optional) number of answers to return. Defaults to a value of `1`.
     * @param scoreThreshold (Optional) minimum answer score needed to be considered a match to questions. Defaults to a value of `0.001`.
     */
    async generateAnswer(question, top, scoreThreshold) {
        const trimmedAnswer = question ? question.trim() : '';
        if (trimmedAnswer.length > 0) {
            const answers = await this.callService(this.endpoint, question, typeof top === 'number' ? top : 1);
            const minScore = typeof scoreThreshold === 'number' ? scoreThreshold : 0.001;
            return answers.filter((ans) => ans.score >= minScore)
                .sort((a, b) => b.score - a.score);
        }
        return [];
    }
    /**
     * Called internally to query the QnA Maker service.
     *
     * @remarks
     * This is exposed to enable better unit testing of the service.
     */
    async callService(endpoint, question, top) {
        return this.queryQnaService(endpoint, question, { top });
    }
    /**
     * Invoked prior to a QnaMessage Event being logged.
     * @param qnaResult The QnA Results for the call.
     * @param turnContext Context object containing information for a single turn of conversation with a user.
     * @param telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @param telemetryMetrics Additional metrics to be logged to telemetry with the QnaMessage event.
     */
    async onQnaResults(qnaResults, turnContext, telemetryProperties, telemetryMetrics) {
        this.fillQnAEvent(qnaResults, turnContext, telemetryProperties, telemetryMetrics).then(data => {
            this.telemetryClient.trackEvent({
                name: qnaTelemetryConstants_1.QnATelemetryConstants.qnaMessageEvent,
                properties: data[0],
                metrics: data[1]
            });
        });
        return;
    }
    /**
     * Fills the event properties for QnaMessage event for telemetry.
     * These properties are logged when the recognizer is called.
     * @param qnaResult Last activity sent from user.
     * @param turnContext Context object containing information for a single turn of conversation with a user.
     * @param telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @returns A dictionary that is sent as properties to BotTelemetryClient.trackEvent method for the QnaMessage event.
     */
    async fillQnAEvent(qnaResults, turnContext, telemetryProperties, telemetryMetrics) {
        var properties = {};
        var metrics = {};
        properties[qnaTelemetryConstants_1.QnATelemetryConstants.knowledgeBaseIdProperty] = this.endpoint.knowledgeBaseId;
        var text = turnContext.activity.text;
        var userName = ('from' in turnContext.activity) ? turnContext.activity.from.name : "";
        // Use the LogPersonalInformation flag to toggle logging PII data, text is a common example
        if (this.logPersonalInformation) {
            if (text) {
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.questionProperty] = text;
            }
            if (userName) {
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.usernameProperty] = userName;
            }
        }
        // Fill in Qna Results (found or not)
        if (qnaResults.length > 0) {
            var queryResult = qnaResults[0];
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.matchedQuestionProperty] = JSON.stringify(queryResult.questions);
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.questionIdProperty] = String(queryResult.id);
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.answerProperty] = queryResult.answer;
            metrics[qnaTelemetryConstants_1.QnATelemetryConstants.scoreMetric] = queryResult.score;
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.articleFoundProperty] = "true";
        }
        else {
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.matchedQuestionProperty] = "No Qna Question matched";
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.questionIdProperty] = "No QnA Question Id matched";
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.answerProperty] = "No Qna Answer matched";
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.articleFoundProperty] = "false";
        }
        // Additional Properties can override "stock" properties.
        if (telemetryProperties != null) {
            properties = Object.assign({}, properties, telemetryProperties);
        }
        // Additional Metrics can override "stock" metrics.
        if (telemetryMetrics != null) {
            metrics = Object.assign({}, metrics, telemetryMetrics);
        }
        return [properties, metrics];
    }
    /**
     * Gets the message from the Activity in the TurnContext, trimmed of whitespaces.
     */
    getTrimmedMessageText(context) {
        const question = (context && context.activity && context.activity.text) ? context.activity.text : '';
        return question.trim();
    }
    /**
     * Called internally to query the QnA Maker service.
     */
    async queryQnaService(endpoint, question, options) {
        const url = `${endpoint.host}/knowledgebases/${endpoint.knowledgeBaseId}/generateanswer`;
        const headers = this.getHeaders(endpoint);
        const queryOptions = { ...this._options, ...options };
        this.validateOptions(queryOptions);
        const qnaResult = await request({
            url: url,
            method: 'POST',
            headers: headers,
            timeout: queryOptions.timeout,
            json: {
                question: question,
                ...queryOptions
            }
        });
        return this.formatQnaResult(qnaResult);
    }
    /**
     * Sorts all QnAMakerResult from highest-to-lowest scoring.
     * Filters QnAMakerResults within threshold specified (default threshold: .001).
     */
    sortAnswersWithinThreshold(answers = [], queryOptions) {
        const minScore = typeof queryOptions.scoreThreshold === 'number' ? queryOptions.scoreThreshold : 0.001;
        return answers.filter((ans) => ans.score >= minScore)
            .sort((a, b) => b.score - a.score);
    }
    /**
     * Emits a trace event detailing a QnA Maker call and its results.
     *
     * @param context Context for the current turn of conversation with the user.
     * @param answers Answers returned by QnA Maker.
     */
    async emitTraceInfo(context, answers, queryOptions) {
        const requestOptions = { ...this._options, ...queryOptions };
        const { scoreThreshold, top, strictFilters, metadataBoost } = requestOptions;
        const traceInfo = {
            message: context.activity,
            queryResults: answers,
            knowledgeBaseId: this.endpoint.knowledgeBaseId,
            scoreThreshold,
            top,
            strictFilters,
            metadataBoost
        };
        return context.sendActivity({
            type: 'trace',
            valueType: QNAMAKER_TRACE_TYPE,
            name: QNAMAKER_TRACE_NAME,
            label: QNAMAKER_TRACE_LABEL,
            value: traceInfo
        });
    }
    /**
     * Sets headers for request to QnAMaker service.
     *
     * The [QnAMakerEndpointKey](#QnAMakerEndpoint.QnAMakerEndpointKey) is set as the value of
     * `Authorization` header for v4.0 and later of QnAMaker service.
     *
     * Legacy QnAMaker services use the `Ocp-Apim-Subscription-Key` header for the QnAMakerEndpoint value instead.
     *
     * [QnAMaker.getHeaders()](#QnAMaker.getHeaders) also gets the User-Agent header value.
     */
    getHeaders(endpoint) {
        const headers = {};
        const isLegacyProtocol = endpoint.host.endsWith('v2.0') || endpoint.host.endsWith('v3.0');
        if (isLegacyProtocol) {
            headers['Ocp-Apim-Subscription-Key'] = endpoint.endpointKey;
        }
        else {
            headers.Authorization = `EndpointKey ${endpoint.endpointKey}`;
        }
        headers['User-Agent'] = this.getUserAgent();
        return headers;
    }
    getUserAgent() {
        const packageUserAgent = `${pjson.name}/${pjson.version}`;
        const platformUserAgent = `(${os.arch()}-${os.type()}-${os.release()}; Node.js,Version=${process.version})`;
        return `${packageUserAgent} ${platformUserAgent}`;
    }
    validateOptions(options) {
        const { scoreThreshold, top } = options;
        if (scoreThreshold) {
            this.validateScoreThreshold(scoreThreshold);
        }
        if (top) {
            this.validateTop(top);
        }
    }
    validateScoreThreshold(scoreThreshold) {
        if (typeof scoreThreshold !== 'number' || !(scoreThreshold > 0 && scoreThreshold < 1)) {
            throw new TypeError(`"${scoreThreshold}" is an invalid scoreThreshold. QnAMakerOptions.scoreThreshold must have a value between 0 and 1.`);
        }
    }
    validateTop(qnaOptionTop) {
        if (!Number.isInteger(qnaOptionTop) || qnaOptionTop < 1) {
            throw new RangeError(`"${qnaOptionTop}" is an invalid top value. QnAMakerOptions.top must be an integer greater than 0.`);
        }
    }
    formatQnaResult(qnaResult) {
        return qnaResult.answers.map((ans) => {
            ans.score = ans.score / 100;
            ans.answer = htmlentities.decode(ans.answer);
            if (ans.qnaId) {
                ans.id = ans.qnaId;
                delete ans.qnaId;
            }
            return ans;
        });
    }
}
exports.QnAMaker = QnAMaker;
//# sourceMappingURL=qnaMaker.js.map